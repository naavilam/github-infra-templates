name: Repo Websites Initializer

on:
  workflow_call:
    inputs:
      repo:
        description: "Target repository or else all."
        required: false
        type: string
        default: ""
      registry_path:
        type: string
        required: false
        default: ".github/registry/repos.yml"
    secrets:
      PROVISIONER_APP_ID:
        required: true
      PROVISIONER_PRIVATE_KEY_PEM:
        required: true

on:
  workflow_dispatch:
    inputs:
      repo:
        description: "Target repository or else all."
        required: false
        type: string
        default: ""

env:
  CENTRAL_REPO: naavilam/github-infra-templates
  TEMPLATE_REF: main
  MAX_PARALLEL: "10"

jobs:
  detect:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set.outputs.matrix }}
      count: ${{ steps.set.outputs.count }}
    steps:
      # checkout do repo que chamou (onde está o registry_path)
      - name: Checkout caller repo
        uses: actions/checkout@v4
        with:
          path: caller

      # checkout do repo central (onde está o script)
      - name: Checkout central repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.CENTRAL_REPO }}
          ref: ${{ env.TEMPLATE_REF }}
          path: central

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install pyyaml requests pyjwt cryptography

      - id: set
        name: Build matrix (missing repos or single target) using GitHub App
        env:
          APP_ID: ${{ secrets.PROVISIONER_APP_ID }}
          APP_PEM: ${{ secrets.PROVISIONER_PRIVATE_KEY_PEM }}
          REGISTRY_PATH: ${{ inputs.registry_path }}
          ONE_REPO: ${{ inputs.repo }}
        run: |
          python - <<'PY'
          import os, json, sys, time
          from pathlib import Path
          import yaml, requests
          import jwt  # PyJWT

          APP_ID = os.environ["APP_ID"]
          APP_PEM = os.environ["APP_PEM"]
          registry_path = (os.environ.get("REGISTRY_PATH") or ".github/registry/repos.yml").strip()
          one_repo = (os.environ.get("ONE_REPO") or "").strip()

          registry_file = Path("caller") / registry_path
          if not registry_file.exists():
            print(f"::error::registry not found: {registry_file}", file=sys.stderr)
            sys.exit(2)

          data = yaml.safe_load(registry_file.read_text(encoding="utf-8")) or {}
          repos = data.get("repos", [])
          if not isinstance(repos, list):
            print("::error::registry.repos must be a list", file=sys.stderr)
            sys.exit(2)

          s_app = requests.Session()
          s_app.headers.update({
            "Accept": "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28",
          })

          def app_jwt():
            now = int(time.time())
            payload = {"iat": now - 30, "exp": now + 9 * 60, "iss": APP_ID}
            return jwt.encode(payload, APP_PEM, algorithm="RS256")

          def installation_token_for_org(org: str) -> str:
            j = app_jwt()
            hdr = {"Authorization": f"Bearer {j}"}

            # pega instalação da org
            r = s_app.get(f"https://api.github.com/orgs/{org}/installation", headers=hdr, timeout=30)
            if r.status_code != 200:
              raise RuntimeError(f"org installation lookup failed {org}: {r.status_code} {r.text}")
            inst_id = r.json().get("id")
            if not inst_id:
              raise RuntimeError(f"no installation id for org {org}")

            # cria token de instalação
            r2 = s_app.post(f"https://api.github.com/app/installations/{inst_id}/access_tokens", headers=hdr, timeout=30)
            if r2.status_code != 201:
              raise RuntimeError(f"installation token failed {org}: {r2.status_code} {r2.text}")
            return r2.json()["token"]

          tok_cache = {}

          def repo_exists(org: str, name: str) -> bool:
            if org not in tok_cache:
              tok_cache[org] = installation_token_for_org(org)

            s = requests.Session()
            s.headers.update({
              "Authorization": f"Bearer {tok_cache[org]}",
              "Accept": "application/vnd.github+json",
              "X-GitHub-Api-Version": "2022-11-28",
            })
            r = s.get(f"https://api.github.com/repos/{org}/{name}", timeout=30)
            if r.status_code in (200, 404):
              return r.status_code == 200
            raise RuntimeError(f"repo_exists unexpected {r.status_code}: {r.text}")

          selected = []

          if one_repo:
            matches = []
            for e in repos:
              org = (e.get("org") or "").strip()
              name = (e.get("name") or "").strip()
              full = f"{org}/{name}"
              if one_repo == name or one_repo == full:
                matches.append({"org": org, "repo": name})
            if not matches:
              print(f"::error::repo '{one_repo}' not found in registry", file=sys.stderr)
              sys.exit(2)
            if len(matches) > 1 and "/" not in one_repo:
              print(f"::error::repo '{one_repo}' is ambiguous; use org/repo", file=sys.stderr)
              sys.exit(2)
            selected = matches

          else:
            for e in repos:
              org = (e.get("org") or "").strip()
              name = (e.get("name") or "").strip()
              if not org or not name:
                continue
              if not repo_exists(org, name):
                selected.append({"org": org, "repo": name})

          matrix = {"include": selected}
          out = json.dumps(matrix)
          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as f:
            f.write(f"matrix={out}\n")
            f.write(f"count={len(selected)}\n")

          print(f"[detect] selected={len(selected)}")
          PY

  init:
    needs: detect
    if: ${{ needs.detect.outputs.count != '0' }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: ${{ fromJSON(env.MAX_PARALLEL) }}
      matrix: ${{ fromJSON(needs.detect.outputs.matrix) }}

    steps:
      - name: Checkout caller repo
        uses: actions/checkout@v4
        with:
          path: caller

      - name: Checkout central repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.CENTRAL_REPO }}
          ref: ${{ env.TEMPLATE_REF }}
          path: central

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install pyyaml requests

      # token do App provisioner para a ORG-alvo (matrix.org) — usado desde o começo
      - name: Create provisioner token (per org)
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.PROVISIONER_APP_ID }}
          private-key: ${{ secrets.PROVISIONER_PRIVATE_KEY_PEM }}
          owner: ${{ matrix.org }}

      - name: Copy registry into central
        env:
          REGISTRY_PATH: ${{ inputs.registry_path }}
        run: |
          set -euo pipefail
          mkdir -p central/.github/registry
          cp "caller/${REGISTRY_PATH}" "central/.github/registry/repos.yml"

      - name: Run initializer (one repo)
        working-directory: central
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          USE_TOKEN_IN_URL: "true"
          ONE_ORG: ${{ matrix.org }}
          ONE_REPO: ${{ matrix.repo }}
        run: |
          python bootstrap/repo_scripts/repo_initializer.py