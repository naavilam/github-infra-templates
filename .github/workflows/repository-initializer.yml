name: Repo Websites Initializer

on:
  workflow_call:
    inputs:
      repo:
        description: "Target repository or else all."
        required: false
        type: string
        default: ""

    secrets:
      PROVISIONER_APP_ID:
        required: true
      PROVISIONER_PRIVATE_KEY_PEM:
        required: true

  workflow_dispatch:
    inputs:
      repo:
        description: "Target repository or else all."
        required: false
        type: string
        default: ""

env:
  CENTRAL_REPO: naavilam/github-infra-templates
  TEMPLATE_REF: main
  MAX_PARALLEL: "10"

jobs:
  detect:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set.outputs.matrix }}
      count: ${{ steps.set.outputs.count }}
    env:
      ORG: ${{ github.repository_owner }}

    steps:
      - name: Checkout caller repo
        uses: actions/checkout@v4
        with:
          path: caller

      - name: Mint provisioner token (org)
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.PROVISIONER_APP_ID }}
          private-key: ${{ secrets.PROVISIONER_PRIVATE_KEY_PEM }}
          owner: ${{ env.ORG }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install pyyaml requests
      
      - name: Guard – Context
        run: |
          echo "github.repository        = ${{ github.repository }}"
          echo "github.repository_owner  = ${{ github.repository_owner }}"
          echo "pwd                      = $(pwd)"
          echo "caller tree:"
          ls -la caller || true

      - name: Guard – Registry content
        env:
          REGISTRY_PATH: ${{ inputs.registry_path }}
        run: |
          set -euo pipefail
          echo "Registry path: caller/${REGISTRY_PATH}"
          test -f "caller/${REGISTRY_PATH}"
          echo "---- registry (head) ----"
          sed -n '1,120p' "caller/${REGISTRY_PATH}"
    
      - name: Guard – App token visibility
        env:
          ORG: ${{ github.repository_owner }}
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          set -euo pipefail
          echo "Testing token visibility for org: $ORG"

          echo "→ /orgs/$ORG"
          curl -sS -H "Authorization: Bearer $GH_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/orgs/$ORG" | jq '.login,.id'

          echo "→ list repos (first 10)"
          curl -sS -H "Authorization: Bearer $GH_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/orgs/$ORG/repos?per_page=10" \
              | jq '.[].name'

      - id: set
        name: Build matrix (missing repos or single target)
        env:
          ORG: ${{ env.ORG }}
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          REGISTRY_PATH: ${{ inputs.registry_path }}
          ONE_REPO: ${{ inputs.repo }}
        run: |
          python - <<'PY'
          import os, json, sys
          from pathlib import Path
          import yaml, requests

          ORG = os.environ["ORG"].strip()
          GH_TOKEN = os.environ["GH_TOKEN"]
          registry_path = (os.environ.get("REGISTRY_PATH") or ".github/registry/repos.yml").strip()
          one_repo = (os.environ.get("ONE_REPO") or "").strip()

          registry_file = Path("caller") / registry_path
          if not registry_file.exists():
            print(f"::error::registry not found: {registry_file}", file=sys.stderr)
            sys.exit(2)

          data = yaml.safe_load(registry_file.read_text(encoding="utf-8")) or {}
          repos = data.get("repos", [])
          if not isinstance(repos, list):
            print("::error::registry.repos must be a list", file=sys.stderr)
            sys.exit(2)

          s = requests.Session()
          s.headers.update({
            "Authorization": f"Bearer {GH_TOKEN}",
            "Accept": "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28",
          })

          def repo_exists(name: str) -> bool:
            r = s.get(f"https://api.github.com/repos/{ORG}/{name}", timeout=30)
            if r.status_code in (200, 404):
              return r.status_code == 200
            raise RuntimeError(f"repo_exists unexpected {r.status_code}: {r.text}")

          # lista de nomes do registry (filtra só os da ORG, por segurança)
          names = []
          for e in repos:
            org = (e.get("org") or "").strip()
            name = (e.get("name") or "").strip()
            if not name:
              continue
            if org and org != ORG:
              continue
            names.append(name)

          selected = []
          if one_repo:
            target = one_repo.split("/")[-1]  # aceita "org/repo" mas ignora org
            if target not in names:
              print(f"::error::repo '{one_repo}' not found in registry for org '{ORG}'", file=sys.stderr)
              sys.exit(2)
            if not repo_exists(target):
              selected.append({"repo": target})
          else:
            for name in names:
              if not repo_exists(name):
                selected.append({"repo": name})

          matrix = {"include": selected}
          out = json.dumps(matrix)
          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as f:
            f.write(f"matrix={out}\n")
            f.write(f"count={len(selected)}\n")

          print(f"[detect] org={ORG} selected={len(selected)}")
          PY

  init:
    needs: detect
    if: ${{ needs.detect.outputs.count != '0' }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 10
      matrix: ${{ fromJSON(needs.detect.outputs.matrix) }}
    env:
      ORG: ${{ github.repository_owner }}

    steps:
      - name: Checkout caller repo
        uses: actions/checkout@v4
        with:
          path: caller

      - name: Checkout central repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.CENTRAL_REPO }}
          ref: ${{ env.TEMPLATE_REF }}
          path: central

      - name: Mint provisioner token (org)
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.PROVISIONER_APP_ID }}
          private-key: ${{ secrets.PROVISIONER_PRIVATE_KEY_PEM }}
          owner: ${{ env.ORG }}

      - name: Copy registry into central
        env:
          REGISTRY_PATH: ${{ inputs.registry_path }}
        run: |
          set -euo pipefail
          mkdir -p central/.github/registry
          cp "caller/${REGISTRY_PATH}" "central/.github/registry/repos.yml"

      - name: Run initializer (one repo)
        working-directory: central
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          USE_TOKEN_IN_URL: "true"
          ONE_ORG: ${{ env.ORG }}
          ONE_REPO: ${{ matrix.repo }}
        run: |
          python bootstrap/repo_scripts/repo_initializer.py