name: Repo Websites Initializer

on:
  workflow_call:
    inputs:
      repo:
        description: "Target repository or else all."
        required: false
        type: string
        default: ""

    secrets:
      PROVISIONER_APP_ID:
        required: true
      PROVISIONER_PRIVATE_KEY_PEM:
        required: true

  workflow_dispatch:
    inputs:
      repo:
        description: "Target repository or else all."
        required: false
        type: string
        default: ""

concurrency:
  group: repository
  cancel-in-progress: true

env:
  CENTRAL_REPO: naavilam/github-infra-templates
  TEMPLATE_REF: main
  MAX_PARALLEL: "10"

jobs:
  detect:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set.outputs.matrix }}
      count: ${{ steps.set.outputs.count }}
    env:
      ORG: ${{ github.repository_owner }}

    steps:
      - name: Checkout caller repo
        uses: actions/checkout@v4
        with:
          path: caller

      - name: Mint provisioner token (org)
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.PROVISIONER_APP_ID }}
          private-key: ${{ secrets.PROVISIONER_PRIVATE_KEY_PEM }}
          owner: ${{ env.ORG }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install pyyaml requests

      - id: set
        name: Build matrix (missing repos or single target) — CENTRAL registry
        env:
          ORG: ${{ env.ORG }}
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          ONE_REPO: ${{ inputs.repo }}
          CENTRAL_REPO: ${{ env.CENTRAL_REPO }}          
          TEMPLATE_REF: ${{ env.TEMPLATE_REF }}      ]
        run: |
          python - <<'PY'
          import os, json, sys
          import requests, yaml

          ORG = os.environ["ORG"].strip()
          GH_TOKEN = os.environ["GH_TOKEN"]
          one_repo = (os.environ.get("ONE_REPO") or "").strip()

          CENTRAL_REPO = (os.environ.get("CENTRAL_REPO") or "naavilam/github-infra-templates").strip()
          TEMPLATE_REF = (os.environ.get("TEMPLATE_REF") or "main").strip()

          s = requests.Session()
          s.headers.update({
            "Authorization": f"Bearer {GH_TOKEN}",
            "Accept": "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28",
          })

          def api_get(url: str):
            r = s.get(url, timeout=30)
            return r

          def load_central_registry():
            # RAW via contents API (public repo, mas ok usar GH_TOKEN)
            path = f"org/org_registry/{ORG.lower()}-registry.yml"
            url = f"https://api.github.com/repos/naavilam/github-infra-templates/contents/{path}" 
            r = api_get(url)
            if r.status_code != 200:
              print(f"::error::central registry not found: {CENTRAL_REPO}/{path}@{TEMPLATE_REF} (http {r.status_code})", file=sys.stderr)
              try:
                print(r.text[:5000], file=sys.stderr)
              except Exception:
                pass
              sys.exit(2)

            j = r.json()
            import base64
            content = (j.get("content") or "").strip()
            if not content:
              print(f"::error::central registry content empty: {CENTRAL_REPO}/{path}@{TEMPLATE_REF}", file=sys.stderr)
              sys.exit(2)

            raw = base64.b64decode(content.encode("utf-8")).decode("utf-8")
            data = yaml.safe_load(raw) or {}
            return data

          def repo_exists(full: str) -> bool:
            r = api_get(f"https://api.github.com/repos/{full}")
            if r.status_code in (200, 404):
              return r.status_code == 200
            raise RuntimeError(f"repo_exists unexpected {r.status_code}: {r.text}")

          data = load_central_registry()

          # aceita: {repos: [...] } ou já lista direta (robusto)
          repos = data.get("repos", data)
          if not isinstance(repos, list):
            print("::error::central registry must contain a list under 'repos:'", file=sys.stderr)
            sys.exit(2)

          # lista de repos do registry (aceita name ou org/name)
          names = []
          for e in repos:
            if not isinstance(e, dict):
              continue
            name = (e.get("name") or "").strip()
            org  = (e.get("org") or ORG).strip()
            if not name:
              continue
            full = f"{org}/{name}" if "/" not in name else name
            names.append(full)

          selected = []
          if one_repo:
            # aceita "repo" ou "org/repo"
            target = one_repo if "/" in one_repo else f"{ORG}/{one_repo}"
            if target not in names:
              print(f"::error::repo '{one_repo}' not found in central registry for org '{ORG}'", file=sys.stderr)
              sys.exit(2)
            if not repo_exists(target):
              selected.append({"repo": target.split("/")[-1]})  # initializer espera só nome
          else:
            for full in names:
              if full.startswith(f"{ORG}/") and (not repo_exists(full)):
                selected.append({"repo": full.split("/")[-1]})

          matrix = {"include": selected}
          out = json.dumps(matrix)

          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as f:
            f.write(f"matrix={out}\n")
            f.write(f"count={len(selected)}\n")

          print(f"[detect] org={ORG} selected={len(selected)}")
          PY

  init:
    needs: detect
    if: ${{ needs.detect.outputs.count != '0' }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 10
      matrix: ${{ fromJSON(needs.detect.outputs.matrix) }}
    env:
      ORG: ${{ github.repository_owner }}

    steps:
      - name: Checkout caller repo
        uses: actions/checkout@v4
        with:
          path: caller

      - name: Checkout central repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.CENTRAL_REPO }}
          ref: ${{ env.TEMPLATE_REF }}
          path: central

      - name: Mint provisioner token (org)
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.PROVISIONER_APP_ID }}
          private-key: ${{ secrets.PROVISIONER_PRIVATE_KEY_PEM }}
          owner: ${{ env.ORG }}

      - name: Run initializer (one repo)
        working-directory: central
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          USE_TOKEN_IN_URL: "true"
          ONE_ORG: ${{ env.ORG }}
          ONE_REPO: ${{ matrix.repo }}
        run: |
          python bootstrap/repo_scripts/repo_initializer.py