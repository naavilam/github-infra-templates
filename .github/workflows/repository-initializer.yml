name: Repo Websites Initializer

on:
  workflow_call:
    inputs:
      repo:
        description: "Target repository or else all."
        required: false
        type: string
        default: ""
      registry_path:
        type: string
        required: false
        default: ".github/registry/repos.yml"
    secrets:
      PROVISIONER_APP_ID:
        required: true
      PROVISIONER_PRIVATE_KEY_PEM:
        required: true

on:
  workflow_dispatch:
    inputs:
      repo:
        description: "Target repository or else all."
        required: false
        type: string
        default: ""

env:
  CENTRAL_REPO: naavilam/github-infra-templates
  TEMPLATE_REF: main
  MAX_PARALLEL: "10"

jobs:
  detect:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set.outputs.matrix }}
      count: ${{ steps.set.outputs.count }}

    steps:
      - name: Checkout caller repo
        uses: actions/checkout@v4
        with:
          path: caller

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install pyyaml requests

      - id: set
        name: Build matrix (missing repos or single target) - single org
        env:
          # 1 org: inferida do registry (ou troque por github.repository_owner se preferir)
          REGISTRY_PATH: ${{ inputs.registry_path }}
          ONE_REPO: ${{ inputs.repo }}
          APP_ID: ${{ secrets.PROVISIONER_APP_ID }}
          APP_PEM: ${{ secrets.PROVISIONER_PRIVATE_KEY_PEM }}
        run: |
          python - <<'PY'
          import os, json, sys, time
          from pathlib import Path
          import yaml, requests, jwt

          APP_ID = os.environ["APP_ID"]
          APP_PEM = os.environ["APP_PEM"]
          registry_path = (os.environ.get("REGISTRY_PATH") or ".github/registry/repos.yml").strip()
          one_repo = (os.environ.get("ONE_REPO") or "").strip()

          registry_file = Path("caller") / registry_path
          if not registry_file.exists():
            print(f"::error::registry not found: {registry_file}", file=sys.stderr)
            sys.exit(2)

          data = yaml.safe_load(registry_file.read_text(encoding="utf-8")) or {}
          repos = data.get("repos", [])
          if not isinstance(repos, list) or not repos:
            print("::error::registry.repos must be a non-empty list", file=sys.stderr)
            sys.exit(2)

          # descobre a ORG única a partir do registry e valida consistência
          orgs = {(e.get("org") or "").strip() for e in repos if (e.get("org") or "").strip()}
          if len(orgs) != 1:
            print(f"::error::expected single org in registry, found: {sorted(orgs)}", file=sys.stderr)
            sys.exit(2)
          ORG = next(iter(orgs))

          s = requests.Session()
          s.headers.update({
            "Accept": "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28",
          })

          def app_jwt():
            now = int(time.time())
            payload = {"iat": now - 30, "exp": now + 9*60, "iss": APP_ID}
            return jwt.encode(payload, APP_PEM, algorithm="RS256")

          def installation_token_for_org(org: str) -> str:
            j = app_jwt()
            hdr = {"Authorization": f"Bearer {j}"}
            r = s.get(f"https://api.github.com/orgs/{org}/installation", headers=hdr, timeout=30)
            if r.status_code != 200:
              raise RuntimeError(f"org installation lookup failed {org}: {r.status_code} {r.text}")
            inst_id = r.json().get("id")
            if not inst_id:
              raise RuntimeError(f"no installation id for org {org}")
            r2 = s.post(f"https://api.github.com/app/installations/{inst_id}/access_tokens", headers=hdr, timeout=30)
            if r2.status_code != 201:
              raise RuntimeError(f"installation token failed {org}: {r2.status_code} {r2.text}")
            return r2.json()["token"]

          TOKEN = installation_token_for_org(ORG)

          def repo_exists(repo_name: str) -> bool:
            rr = requests.get(
              f"https://api.github.com/repos/{ORG}/{repo_name}",
              headers={
                "Authorization": f"Bearer {TOKEN}",
                "Accept": "application/vnd.github+json",
                "X-GitHub-Api-Version": "2022-11-28",
              },
              timeout=30,
            )
            if rr.status_code in (200, 404):
              return rr.status_code == 200
            raise RuntimeError(f"repo_exists unexpected {rr.status_code}: {rr.text}")

          selected = []

          if one_repo:
            # aceita "repo" ou "org/repo"
            target_repo = one_repo.split("/")[-1]
            # valida no registry
            if not any((e.get("name") or "").strip() == target_repo for e in repos):
              print(f"::error::repo '{one_repo}' not found in registry", file=sys.stderr)
              sys.exit(2)
            selected = [{"org": ORG, "repo": target_repo}]
          else:
            for e in repos:
              name = (e.get("name") or "").strip()
              if not name:
                continue
              if not repo_exists(name):
                selected.append({"org": ORG, "repo": name})

          matrix = {"include": selected}
          out = json.dumps(matrix)
          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as f:
            f.write(f"matrix={out}\n")
            f.write(f"count={len(selected)}\n")

          print(f"[detect] ORG={ORG} selected={len(selected)}")
          PY

  init:
    needs: detect
    if: ${{ needs.detect.outputs.count != '0' }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: ${{ fromJSON(env.MAX_PARALLEL) }}
      matrix: ${{ fromJSON(needs.detect.outputs.matrix) }}

    steps:
      - name: Checkout caller repo
        uses: actions/checkout@v4
        with:
          path: caller

      - name: Checkout central repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.CENTRAL_REPO }}
          ref: ${{ env.TEMPLATE_REF }}
          path: central

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install pyyaml requests

      # token do App provisioner para a ORG-alvo (matrix.org) — usado desde o começo
      - name: Create provisioner token (per org)
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.PROVISIONER_APP_ID }}
          private-key: ${{ secrets.PROVISIONER_PRIVATE_KEY_PEM }}
          owner: ${{ matrix.org }}

      - name: Copy registry into central
        env:
          REGISTRY_PATH: ${{ inputs.registry_path }}
        run: |
          set -euo pipefail
          mkdir -p central/.github/registry
          cp "caller/${REGISTRY_PATH}" "central/.github/registry/repos.yml"

      - name: Run initializer (one repo)
        working-directory: central
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          USE_TOKEN_IN_URL: "true"
          ONE_ORG: ${{ matrix.org }}
          ONE_REPO: ${{ matrix.repo }}
        run: |
          python bootstrap/repo_scripts/repo_initializer.py