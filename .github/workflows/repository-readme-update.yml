name: Update org READMEs

on:
  workflow_call:
    inputs:
      repo:
        description: "Target repository or else all."
        required: false
        type: string
        default: ""
    secrets:
      PROVISIONER_APP_ID:
        required: true
      PROVISIONER_PRIVATE_KEY_PEM:
        required: true

permissions:
  contents: write

concurrency:
  group: readme
  cancel-in-progress: true

env:
  CENTRAL_REPO: naavilam/github-infra-templates
  TEMPLATE_REF: main
  MAX_PARALLEL: "10"

jobs:
  plan:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set.outputs.matrix }}

    steps:
      - name: Checkout manager repo (registry)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install pyyaml requests

      - id: set
        name: Build matrix from CENTRAL org registry (with embedded cfg)
        shell: bash
        env:
          ORG: ${{ env.ORG }}
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          REPO_FILTER: ${{ inputs.repo }}
          CENTRAL_REPO: ${{ env.CENTRAL_REPO }}   # ex: naavilam/github-infra-templates
          CENTRAL_REF:  ${{ env.TEMPLATE_REF }}  # ex: main
        run: |
          set -euo pipefail

          MATRIX="$(python - <<'PY'
          import os, sys, json, base64, requests, yaml
          from urllib.parse import quote

          org = (os.environ.get("ORG") or "").strip()
          if not org:
            print("::error::ORG env is required", file=sys.stderr)
            sys.exit(2)

          org_lc = org.lower()

          gh_token = os.environ["GH_TOKEN"]
          repo_filter = (os.environ.get("REPO_FILTER") or "").strip()
          central_repo = (os.environ.get("CENTRAL_REPO") or "").strip()
          central_ref  = (os.environ.get("CENTRAL_REF")  or "main").strip()

          if not central_repo:
            print("::error::CENTRAL_REPO env is required", file=sys.stderr)
            sys.exit(2)

          # novo caminho do registry por org
          registry_path = f"org/org_registry/{org_lc}-registry.yml"

          s = requests.Session()
          s.headers.update({
            "Authorization": f"Bearer {gh_token}",
            "Accept": "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28",
          })

          # baixa via contents API
          url = f"https://api.github.com/repos/{central_repo}/contents/{quote(registry_path)}?ref={quote(central_ref)}"
          r = s.get(url, timeout=30)
          if r.status_code != 200:
            print(f"::error::cannot fetch registry from {central_repo}:{registry_path}@{central_ref} (http {r.status_code})", file=sys.stderr)
            try:
              print(r.text, file=sys.stderr)
            except Exception:
              pass
            sys.exit(2)

          j = r.json()
          content_b64 = j.get("content","")
          if not content_b64:
            print(f"::error::registry content empty: {central_repo}:{registry_path}@{central_ref}", file=sys.stderr)
            sys.exit(2)

          raw = base64.b64decode(content_b64.encode("utf-8")).decode("utf-8")
          data = yaml.safe_load(raw) or {}

          # novo schema: repos:
          items = data.get("repos", [])
          if not isinstance(items, list):
            items = []

          def norm(s: str) -> str:
            return (s or "").strip().lower()

          # filtro aceita "name" OU "org/name"
          target_full = None
          target_name = None
          if repo_filter:
            if "/" in repo_filter:
              target_full = norm(repo_filter)
            else:
              target_name = norm(repo_filter)

          include = []

          for it in items:
            if not isinstance(it, dict):
              continue

            name = str(it.get("name","")).strip()
            if not name:
              continue

            # org default = org do arquivo (ou do env)
            org_item = str(it.get("org","")).strip() or org_lc
            full = f"{org_item}/{name}"

            # aplica filtro
            if target_full and norm(full) != target_full:
              continue
            if target_name and norm(name) != target_name:
              continue

            # placeholders mínimos pro README/site builder
            course_id = (str(it.get("id") or "").strip()
                        or (name.split("-",1)[0] if "-" in name else name))

            title = str(it.get("title") or "").strip()
            if not title:
              rest = name.split("-", 1)[1] if "-" in name else name
              title = rest.replace("-", " ").strip()

            site_url = str(it.get("site_url") or "").strip()
            if not site_url:
              site_url = f"https://{org_item}.github.io/{name}"

            area  = str(it.get("academic_area") or "").strip()
            level = str(it.get("academic_level") or "").strip()
            if level:
              lvl = level.lower().strip()
              if lvl == "undergraduate": level = "Undergraduate Course"
              elif lvl == "graduate": level = "Graduate Course"
              else: level = level[:1].upper() + level[1:]

            tagline = str(it.get("readme_tagline") or "").strip()
            if not tagline:
              parts = [p for p in [area, level] if p]
              tagline = " • ".join(parts) if parts else "lectures • notebooks • references"

            cfg = {
              "TITLE_1": course_id,
              "TITLE_2": title,
              "REPO_TAGLINE": tagline,
              "CTA_TEXT": str((it.get("readme_cta_text") or "Access the full course website")).strip(),
              "THEME": str((it.get("readme_theme") or "coding")).strip(),
              "SITE_URL": site_url,
              "ASSETS_DIR": str((it.get("readme_assets_dir") or ".github/readme")).strip(),
              "HERO_FILE": str((it.get("site_hero_image") or "")).strip(),
            }

            payload = json.dumps(cfg, separators=(",", ":"), ensure_ascii=False).encode("utf-8")
            cfg_b64 = base64.urlsafe_b64encode(payload).decode("ascii")

            include.append({"repo": full, "cfg_b64": cfg_b64})

          print(json.dumps({"include": include}, ensure_ascii=False))
          PY
          )"

          echo "matrix=${MATRIX}" >> "$GITHUB_OUTPUT"
          echo "count=$(python - <<'PY'
          import os, json
          m = json.loads(os.environ["MATRIX"])
          print(len(m.get("include",[])))
          PY
          )" >> "$GITHUB_OUTPUT"

  apply:
    needs: plan
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      max-parallel: 10
      matrix: ${{ fromJson(needs.plan.outputs.matrix) }}

    steps:          
      - name: Mint Provisioner GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.PROVISIONER_APP_ID }}
          private-key: ${{ secrets.PROVISIONER_PRIVATE_KEY_PEM }}
          owner: ${{ github.repository_owner }}

      - name: Checkout target repo
        uses: actions/checkout@v4
        with:
          repository: ${{ matrix.repo }}
          token: ${{ steps.app-token.outputs.token }}
          path: target
          fetch-depth: 0

      - name: Checkout central templates + scripts
        uses: actions/checkout@v4
        with:
          repository: ${{ env.CENTRAL_REPO }}
          ref: ${{ env.TEMPLATE_REF }}
          path: central
          sparse-checkout: |
            bootstrap/repo_readme
            bootstrap/repo_scripts/build_readme.py
          sparse-checkout-cone-mode: false


      - name: Debug matrix item (safe)
        shell: bash
        run: |
          set -euo pipefail
          echo "=== matrix item ==="
          echo "matrix.repo=${{ matrix.repo }}"
          echo "workspace=${{ github.workspace }}"
          echo "pwd=$(pwd)"
          echo ""

      - name: Debug filesystem (safe)
        shell: bash
        run: |
          set -euo pipefail
          echo "=== tree (top) ==="
          ls -la
          echo ""
          echo "=== tree (target) ==="
          ls -la target || true
          echo ""
          echo "=== tree (target/.github) ==="
          ls -la target/.github || true
          echo ""
          echo "=== tree (target/.github/readme) ==="
          ls -la target/.github/readme || true
          echo ""

      # se você está gerando _cfg/readme.yml a partir de base64/JSON/YAML do registry,
      # garanta que ele existe e MOSTRE o conteúdo (isso é safe).
      - name: Debug cfg file (safe)
        shell: bash
        run: |
          set -euo pipefail
          echo "=== cfg ==="
          ls -la _cfg || true
          if [[ -f "_cfg/readme.yml" ]]; then
            echo "--- _cfg/readme.yml ---"
            cat _cfg/readme.yml
            echo "------------------------"
          else
            echo "::warning::_cfg/readme.yml not found"
          fi
          echo ""

      - name: Debug before build (git + repo state) (safe)
        shell: bash
        run: |
          set -euo pipefail
          cd target
          echo "=== target git state (before) ==="
          echo "repo=$(git remote get-url origin || true)"
          echo "branch=$(git rev-parse --abbrev-ref HEAD || true)"
          echo "head=$(git rev-parse --short HEAD || true)"
          echo ""
          echo "--- status --porcelain ---"
          git status --porcelain=v1 || true
          echo ""
          echo "--- ls ---"
          ls -la
          echo ""
          echo "--- has README.md? ---"
          if [[ -f README.md ]]; then echo "yes"; else echo "no"; fi
          echo ""

      - name: Write cfg file (from matrix, local workspace)
        shell: bash
        env:
          CFG_B64: ${{ matrix.cfg_b64 }}
        run: |
          set -euo pipefail
          mkdir -p _cfg
          python - <<'PY'
          import os, base64, json, yaml
          data = base64.b64decode(os.environ["CFG_B64"]).decode("utf-8")
          cfg = json.loads(data)  # se você guardar JSON no registry
          with open("_cfg/readme.yml", "w", encoding="utf-8") as f:
            yaml.safe_dump(cfg, f, sort_keys=False, allow_unicode=True)
          print("[ok] wrote _cfg/readme.yml")
          PY

      - name: Build README (from central + cfg)
        shell: bash
        run: |
          set -euo pipefail

          python central/bootstrap/repo_scripts/build_readme.py \
            --repo target \
            --central central/bootstrap/repo_readme \
            --cfg _cfg/readme.yml

      - name: Debug after build (what changed?) (safe)
        shell: bash
        run: |
          set -euo pipefail
          cd target
          echo "=== target git state (after) ==="
          echo "--- status --porcelain ---"
          git status --porcelain=v1 || true
          echo ""
          echo "--- diff --name-status ---"
          git diff --name-status || true
          echo ""
          echo "--- diffstat ---"
          git diff --stat || true
          echo ""
          echo "--- show README head (if exists) ---"
          if [[ -f README.md ]]; then
            head -n 40 README.md
          else
            echo "::warning::README.md still not present"
          fi
          echo ""
          echo "--- list .github/readme (if exists) ---"
          ls -la .github/readme || true
          echo ""


      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install pyyaml

      - name: Write _cfg/readme.yml from matrix payload
        shell: bash
        env:
          CFG_B64: ${{ matrix.cfg_b64 }}
        run: |
          set -euo pipefail
          mkdir -p _cfg
          python - <<'PY'
          import os, json, base64, yaml
          b64 = os.environ["CFG_B64"]
          data = base64.urlsafe_b64decode(b64.encode("ascii")).decode("utf-8")
          cfg = json.loads(data)
          with open("_cfg/readme.yml", "w", encoding="utf-8") as f:
            yaml.safe_dump(cfg, f, sort_keys=False, allow_unicode=True)
          print("[ok] wrote _cfg/readme.yml")
          PY

      - name: Build + commit + push
        shell: bash
        run: |
          set -euo pipefail

          python central/bootstrap/repo_scripts/build_readme.py \
            --repo target \
            --central central/bootstrap/repo_readme \
            --repo-cfg _cfg/readme.yml
          
          cd target

          # identidade do bot (org do manager atual)
          ORG_LC="$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')"
          BOT="${ORG_LC}-provisioner-app[bot]"
          git config user.name "${BOT}"
          git config user.email "${BOT}@users.noreply.github.com"

          git add README.md .github/readme || true

          if git diff --cached --quiet; then
            echo "No changes."
            exit 0
          fi

          git commit -m "Update files"
          git push