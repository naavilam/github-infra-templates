name: Provision Manager Website + Secrets

on:
  workflow_dispatch:
    inputs:
      org:
        description: "Target organization"
        required: true
      templates_repo:
        description: "Templates repo (owner/name)"
        required: false
        default: "naavilam/github-infra-templates"
      templates_ref:
        description: "Branch/tag/sha in templates repo"
        required: false
        default: "main"

permissions:
  contents: read


jobs:
  mint_token:
    runs-on: ubuntu-latest
    outputs:
      token: ${{ steps.app_token.outputs.token }}

    steps:
      - name: Create Provisioner installation token
        id: app_token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.PROVISIONER_APP_ID }}
          private-key: ${{ secrets.PROVISIONER_PRIVATE_KEY_PEM }}
          owner: ${{ inputs.org }}

  provision:
    runs-on: ubuntu-latest
    needs: mint_token
    environment: ${{ inputs.org }} 
    steps:
      # 1) Checkout templates repo (public -> GITHUB_TOKEN ok)
      - name: Checkout templates
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.templates_repo }}
          ref: ${{ inputs.templates_ref }}
          path: templates

      # 3) Install gh CLI (usually already present, but keep explicit)
      - name: Ensure gh is available
        run: gh --version

      - name: Sanity check token present
        env:
          GH_TOKEN: ${{ needs.mint_token.outputs.token }}
        run: |
          set -euo pipefail
          [[ -n "${GH_TOKEN:-}" ]] || (echo "GH_TOKEN is empty (mint_token output not wired)" >&2; exit 1)
          gh auth status

      # 4) Create repo {org}.github.io if missing
      - name: Create {org}.github.io repo (if missing)
        env:
          GH_TOKEN: ${{ needs.mint_token.outputs.token }}
          ORG: ${{ inputs.org }}
        run: |
          set -euo pipefail
          REPO="${ORG}.github.io"

          if gh api "repos/${ORG}/${REPO}" >/dev/null 2>&1; then
            echo "Repo already exists: ${ORG}/${REPO}"
          else
            echo "Creating repo: ${ORG}/${REPO}"
            gh api "orgs/${ORG}/repos" -X POST -f name="$REPO" -f private=false -f description="Org website for ${ORG}" >/dev/null
          fi

      # 5) Build the site payload from templates (website + registry + assets + workflows)
      - name: Assemble website payload
        env:
          ORG: ${{ inputs.org }}
        run: |
          set -euo pipefail

          ROOT="$PWD"
          OUT="$ROOT/out"
          rm -rf "$OUT"
          mkdir -p "$OUT/.github/workflows"
          mkdir -p "$OUT/.github/registry"
          mkdir -p "$OUT/_posts" 

          # --- Website base ---
          # copies everything from manager_website/ into repo root
          rsync -a --delete \
            "$ROOT/templates/manager/manager_website/" \
            "$OUT/"

          # --- Registry for this org ---
          REG="$ROOT/templates/manager/manager_registry/${ORG}-registry.yml"
          if [[ ! -f "$REG" ]]; then
            echo "❌ Missing registry file: $REG" >&2
            echo "Available registry files:" >&2
            ls -la "$ROOT/templates/manager/manager_registry" >&2 || true
            exit 1
          fi
          cp "$REG" "$OUT/.github/registry/registry.yml"

          # --- Assets for this org ---
          ASSETS_DIR="$ROOT/templates/manager/manager_assets/${ORG}"
          if [[ ! -d "$ASSETS_DIR" ]]; then
            echo "❌ Missing assets dir: $ASSETS_DIR" >&2
            echo "Available assets dirs:" >&2
            ls -la "$ROOT/templates/manager/manager_assets" >&2 || true
            exit 1
          fi

          # Copy assets "as-is" into repo root (preserves internal structure)
          rsync -a \
            "$ASSETS_DIR/" \
            "$OUT/"

          # --- Workflows ---
          rsync -a --delete \
            "$ROOT/templates/manager/manager_workflows/" \
            "$OUT/.github/workflows/"

          echo "✅ Payload assembled at: $OUT"
          find "$OUT" -maxdepth 3 -type f | sed 's#^'"$OUT"'#OUT#'

      - name: Install python deps for assembly
        run: |
          python -m pip install --upgrade pip
          pip install pyyaml
        
      - name: Generate _posts from registry (assembly_posts.py)
        env:
          ORG: ${{ inputs.org }}
        run: |
          set -euo pipefail
          python -V

          REG="$GITHUB_WORKSPACE/out/.github/registry/registry.yml"
          OUTPOSTS="$GITHUB_WORKSPACE/out/_posts"

          # ajuste o caminho do script conforme você decidir onde ele fica no templates repo
          SCRIPT="$GITHUB_WORKSPACE/templates/manager/manager_scripts/assembly_posts.py"

          if [[ ! -f "$SCRIPT" ]]; then
            echo " Missing script: $SCRIPT" >&2
            exit 1
          fi

          python "$SCRIPT" \
            --org "$ORG" \
            --registry "$REG" \
            --out-posts "$OUTPOSTS"

          echo "_posts generated:"
          ls -la "$OUTPOSTS" || true

      - name: Inject GA tracking id into out/_config.yml
        env:
          ORG: ${{ inputs.org }}
        run: |
          set -euo pipefail

          python -m pip install --upgrade pip
          pip install pyyaml

          python - <<'PY'
          import os, yaml

          org = os.environ["ORG"]

          orgs_yml = os.path.join(os.environ["GITHUB_WORKSPACE"], "templates", "orgs.yml")
          config_yml = os.path.join(os.environ["GITHUB_WORKSPACE"], "out", "_config.yml")

          with open(orgs_yml, "r", encoding="utf-8") as f:
              data = yaml.safe_load(f) or {}

          orgs = data.get("orgs", [])
          entry = next((x for x in orgs if x.get("name") == org), None)
          if not entry:
              raise SystemExit(f"ORG not found in orgs.yml: {org}")

          ga_id = entry.get("ga_analytics")  # string direta

          with open(config_yml, "r", encoding="utf-8") as f:
              cfg = yaml.safe_load(f) or {}

          if ga_id:
              cfg["ga_tracking_id"] = ga_id
              print(f"Injected ga_tracking_id = {ga_id}")
          else:
              cfg.pop("ga_tracking_id", None)
              print("No GA tracking id found; ga_tracking_id not set")

          with open(config_yml, "w", encoding="utf-8") as f:
              yaml.safe_dump(cfg, f, sort_keys=False, allow_unicode=True)
          PY


      # 6) Push payload into {org}.github.io using app token
      - name: Push content to {org}.github.io
        env:
          GH_TOKEN: ${{ needs.mint_token.outputs.token }}
          ORG: ${{ inputs.org }}
        run: |
          set -euo pipefail
          REPO="${ORG}.github.io"

          git config --global user.name  "provisioner[bot]"
          git config --global user.email "provisioner[bot]@users.noreply.github.com"

          rm -rf target
          mkdir -p target
          cd target

          git init
          git branch -M main

          # Add all assembled files
          rsync -a "$GITHUB_WORKSPACE/out/" .

          git add -A
          git commit -m "Provision manager website for ${ORG}" || echo "Nothing to commit."

          git remote add origin "https://x-access-token:${GH_TOKEN}@github.com/${ORG}/${REPO}.git"
          git push -u origin main --force

      # 7) Set 6 org secrets on {org}
      - name: Set org secrets (dispatcher + provisioner)
        env:
          GH_TOKEN: ${{ needs.mint_token.outputs.token }}
          ORG: ${{ inputs.org }}
          DISPATCHER_APP_ID: ${{ vars.DISPATCHER_APP_ID }}
          DISPATCHER_PRIVATE_KEY_PEM: ${{ secrets.DISPATCHER_PRIVATE_KEY_PEM }}
          PROVISIONER_APP_ID: ${{ vars.PROVISIONER_APP_ID }}
          PROVISIONER_PRIVATE_KEY_PEM: ${{ secrets.PROVISIONER_PRIVATE_KEY_PEM }}
        run: |
          set -euo pipefail

          # You asked for 6 org secrets: IDs + PEMs for dispatcher and provisioner
          echo "$DISPATCHER_APP_ID"            | gh secret set DISPATCHER_APP_ID            --org "$ORG" --visibility private
          echo "$DISPATCHER_PRIVATE_KEY_PEM"   | gh secret set DISPATCHER_PRIVATE_KEY_PEM   --org "$ORG" --visibility private
          echo "$PROVISIONER_APP_ID"           | gh secret set PROVISIONER_APP_ID           --org "$ORG" --visibility private
          echo "$PROVISIONER_PRIVATE_KEY_PEM"  | gh secret set PROVISIONER_PRIVATE_KEY_PEM  --org "$ORG" --visibility private

          echo "✅ Org secrets set on $ORG"

      # 8) Set repo secrets on {org}.github.io (auditor only)
      - name: Set auditor secrets on {org}.github.io
        env:
          GH_TOKEN: ${{ needs.mint_token.outputs.token }}
          ORG: ${{ inputs.org }}
          AUDITOR_APP_ID: ${{ vars.AUDITOR_APP_ID }}
          AUDITOR_PRIVATE_KEY_PEM: ${{ secrets.AUDITOR_PRIVATE_KEY_PEM }}
        run: |
          set -euo pipefail

          REPO="${ORG}.github.io"
          TARGET="${ORG}/${REPO}"

          echo "$AUDITOR_APP_ID"           | gh secret set AUDITOR_APP_ID           --repo "$TARGET"
          echo "$AUDITOR_PRIVATE_KEY_PEM"  | gh secret set AUDITOR_PRIVATE_KEY_PEM  --repo "$TARGET"

          echo "✅ Auditor secrets set on $TARGET"

      # 9) (Optional) Enable Pages (for org site it usually just needs repo + settings)
      - name: Enable GitHub Pages (optional)
        env:
          GH_TOKEN: ${{ needs.mint_token.outputs.token }}
          ORG: ${{ inputs.org }}
        run: |
          set -euo pipefail
          REPO="${ORG}.github.io"

          # Try to enable Pages from main branch root. If already enabled, ignore.
          gh api "repos/${ORG}/${REPO}/pages" -X POST \
            -f source[branch]=main \
            -f source[path]="/" \
            >/dev/null 2>&1 || true

          echo "✅ Pages enable attempted for ${ORG}/${REPO}"


      # se o primeiro falhar
      # - name: Enable GitHub Pages on main (root)
      #   env:
      #     GH_TOKEN: ${{ needs.mint_token.outputs.token }}
      #     ORG: ${{ inputs.org }}
      #   run: |
      #     set -euo pipefail
      #     REPO="${ORG}.github.io"

      #     # Cria Pages se não existir; se existir, atualiza.
      #     # POST pode falhar se já existir, então tentamos POST e depois PUT.
      #     gh api "repos/${ORG}/${REPO}/pages" -X POST \
      #       -f source[branch]=main \
      #       -f source[path]="/" \
      #       >/dev/null 2>&1 || true

      #     # Atualiza a fonte para main:/ (idempotente)
      #     gh api "repos/${ORG}/${REPO}/pages" -X PUT \
      #       -f source[branch]=main \
      #       -f source[path]="/" \
      #       >/dev/null 2>&1 || true

      #     echo "✅ Pages set to main:/ for ${ORG}/${REPO}"