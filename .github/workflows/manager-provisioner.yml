name: Provision Manager Website + Secrets

on:
  workflow_call:
    inputs:
    org:
      description: "Target organization"
      required: true
  workflow_dispatch:
    inputs:
      org:
        description: "Target organization"
        required: true
      templates_repo:
        description: "Templates repo (owner/name)"
        required: false
        default: "naavilam/github-infra-templates"
      templates_ref:
        description: "Branch/tag/sha in templates repo"
        required: false
        default: "main"

permissions:
  contents: read
  id-token: write

concurrency:
  group: manager
  cancel-in-progress: true

jobs:
  provision:
    runs-on: ubuntu-latest
    environment: ${{ inputs.org || github.event.inputs.org }}

    steps:
      - name: Ensure gh is available
        run: gh --version

      # 0) Mint token (no mesmo job) + exporta para GH_TOKEN
      - name: Create Provisioner installation token
        id: app_token
        uses: actions/create-github-app-token@v1
        with:
          # ROOT creds (repo-level)
          app-id: ${{ vars.ROOT_PROVISIONER_APP_ID }}
          private-key: ${{ secrets.ROOT_PROVISIONER_PRIVATE_KEY_PEM }}
          owner: ${{ inputs.org }}

      - name: Debug runner + workspace
        run: |
          set -euo pipefail
          echo "PWD=$PWD"
          echo "GITHUB_WORKSPACE=$GITHUB_WORKSPACE"
          ls -la


      - name: Export GH_TOKEN for rest of job (no leak)
        shell: bash
        run: |
          set -euo pipefail
          tok='${{ steps.app_token.outputs.token }}'
          echo "mint: token length = ${#tok}"
          [[ "${#tok}" -ge 20 ]]
          echo "GH_TOKEN=$tok" >> "$GITHUB_ENV"

      - name: Sanity check auth
        shell: bash
        run: |
          set -euo pipefail
          gh auth status

      # 1) Checkout templates repo (public -> GITHUB_TOKEN ok)
      - name: Checkout templates
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.templates_repo }}
          ref: ${{ inputs.templates_ref }}
          path: templates


      - name: Debug templates HEAD (prove what you are using)
        run: |
          set -euo pipefail
          echo "templates_repo=${{ inputs.templates_repo }}"
          echo "templates_ref=${{ inputs.templates_ref }}"
          cd templates
          echo "HEAD:"
          git rev-parse HEAD
          git log -1 --oneline
          echo "Recent changes (last commit files):"
          git show --name-only --pretty="" HEAD | sed '/^$/d' || true

      - name: Debug orgs.yml + registry chosen
        env:
          ORG: ${{ inputs.org }}
        run: |
          set -euo pipefail
          echo "Looking for org in templates/orgs.yml"
          ls -la templates/orgs.yml
          echo "grep ORG name:"
          grep -n "name: ${ORG}" -n templates/orgs.yml || true
          echo
          echo "Registry file:"
          ls -la "templates/org/org_registry/${ORG}-registry.yml" || true

      # 2) Create repo {org}.github.io if missing
      - name: Create {org}.github.io repo (if missing)
        env:
          ORG: ${{ inputs.org }}
        run: |
          set -euo pipefail

          : "${ORG:?ORG is required}"

          REPO="${ORG}.github.io"
          FULL="${ORG}/${REPO}"

          echo "Target repo: ${FULL}"

          # 1) Create repo if missing
          if gh api "repos/${FULL}" >/dev/null 2>&1; then
            echo "Repo already exists: ${FULL}"
          else
            echo "Creating repo: ${FULL}"
            gh api "orgs/${ORG}/repos" -X POST \
              -f name="$REPO" \
              -f private=false \
              -f description="Org website for ${ORG}" >/dev/null
          fi

          # 2) Wait until GitHub finishes repo provisioning
          echo "Waiting for repo to be fully provisioned: ${FULL}"
          for i in 1 2 3 4 5 6 7 8 9 10; do
            if gh api "repos/${FULL}" -q '.name' >/dev/null 2>&1; then
              echo " Repo reachable (attempt $i/10)"
              break
            fi
            echo "…repo not reachable yet (attempt $i/10). Waiting..."
            sleep $((i * 2))
          done

          # 3) Enforce PUBLIC (handles repos created as private by org defaults/policies)
          echo "Ensuring repo is PUBLIC: ${FULL}"
          for i in 1 2 3 4 5 6; do
            if gh api "repos/${FULL}" -X PATCH -f private=false >/dev/null 2>&1; then
              echo " Repo visibility set to public"
              break
            fi

            echo "…cannot update visibility yet (attempt $i/6). Likely previous repo operation still in progress. Waiting..."
            sleep $((i * 3))
          done

          # 4) Verify
          is_private="$(gh api "repos/${FULL}" -q '.private')"
          echo "Repo private? ${is_private}"
          if [[ "$is_private" == "true" ]]; then
            echo " Repo still private after retries: ${FULL}" >&2
            exit 1
          fi

      # 3) Build payload
      - name: Assemble website payload
        env:
          ORG: ${{ inputs.org }}
        run: |
          set -euo pipefail

          ROOT="$PWD"
          OUT="$ROOT/out"
          rm -rf "$OUT"

          # 1) Copia o site primeiro (rsync --delete pode remover .github)
          mkdir -p "$OUT/_posts"

          rsync -a --delete \
            "$ROOT/templates/manager/manager_website/" \
            "$OUT/"

          # 2) Assets (depende da org)
          ASSETS_DIR="$ROOT/templates/manager/manager_assets/${ORG}"
          if [[ ! -d "$ASSETS_DIR" ]]; then
            echo "Missing assets dir: $ASSETS_DIR" >&2
            ls -la "$ROOT/templates/manager/manager_assets" >&2 || true
            exit 1
          fi
          rsync -a "$ASSETS_DIR/" "$OUT/"

          # 3) Workflows (garante destino DEPOIS do rsync do site)
          mkdir -p "$OUT/.github/workflows"
          rsync -a --delete \
            "$ROOT/templates/manager/manager_workflows/" \
            "$OUT/.github/workflows/"

          echo "Payload assembled at: $OUT"


      - name: Install python deps for assembly
        run: |
          python -m pip install --upgrade pip
          pip install pyyaml

      - name: Generate _posts from registry (assembly_posts.py)
        env:
          ORG: ${{ inputs.org }}
        run: |
          set -euo pipefail
          REG="$GITHUB_WORKSPACE/templates/org/org_registry/${ORG}-registry.yml"
          OUTPOSTS="$GITHUB_WORKSPACE/out/_posts"
          SCRIPT="$GITHUB_WORKSPACE/templates/manager/manager_scripts/assembly_posts.py"

          [[ -f "$SCRIPT" ]] || (echo "Missing script: $SCRIPT" >&2; exit 1)

          python "$SCRIPT" \
            --registry "$REG" \
            --out-posts "$OUTPOSTS"
    
      - name: Write site URL to README.md
        env:
          ORG: ${{ inputs.org }}
        run: |
          set -euo pipefail
          echo "https://${ORG}.github.io" > "$GITHUB_WORKSPACE/out/README.md"
          
      - name: Inject GA tracking id + title + url into out/_config.yml
        env:
          ORG: ${{ inputs.org }}
        run: |
          set -euo pipefail

          python -m pip install --upgrade pip
          pip install pyyaml

          python - <<'PY'
          import os, yaml, sys

          org = os.environ["ORG"]
          ws  = os.environ["GITHUB_WORKSPACE"]

          orgs_yml   = os.path.join(ws, "templates", "orgs.yml")
          config_yml = os.path.join(ws, "out", "_config.yml")

          # --- Load orgs.yml ---
          with open(orgs_yml, "r", encoding="utf-8") as f:
              data = yaml.safe_load(f) or {}

          entry = next(
              (x for x in (data.get("orgs") or []) if x.get("name") == org),
              None
          )

          if not entry:
              raise SystemExit(f"ORG not found in orgs.yml: {org}")

          # --- Values to inject ---
          ga_id = entry.get("ga_analytics")
          title = entry.get("title")                     # from registry
          url   = f"https://{org}.github.io"             # runtime site URL
          github_url = f"https://github.com/{org}/{org}.github.io" 

          # --- Load existing _config.yml ---
          with open(config_yml, "r", encoding="utf-8") as f:
              cfg = yaml.safe_load(f) or {}

          # --- GA tracking id ---
          if ga_id:
              cfg["ga_tracking_id"] = ga_id
              print(f"Injected ga_tracking_id = {ga_id}")
          else:
              cfg.pop("ga_tracking_id", None)
              print("No GA tracking id found; ga_tracking_id removed")

          # --- Title ---
          if title:
              cfg["title"] = title
              print(f"Injected title = {title}")
          else:
              print("No title found in orgs.yml; keeping existing title")

          # --- URL (always set, site public URL) ---
          cfg["url"] = url
          print(f"Injected url = {url}")

          # --- URL (always set, site public URL) ---
          cfg["github_url"] = github_url
          print(f"Injected github_url = {github_url}")


          # --- Write back ---
          with open(config_yml, "w", encoding="utf-8") as f:
              yaml.safe_dump(cfg, f, sort_keys=False, allow_unicode=True)

          print(" _config.yml updated successfully")
          PY

      # 4) Push payload into {org}.github.io
      - name: Push content to {org}.github.io
        env:
          ORG: ${{ inputs.org }}
        run: |
          set -euo pipefail
          REPO="${ORG}.github.io"

          git config --global user.name  "templates-provisioner-app[bot]"
          git config --global user.email "templates-provisioner-app[bot]@users.noreply.github.com"

          rm -rf target
          mkdir -p target
          cd target

          git init
          git branch -M main

          rsync -a "$GITHUB_WORKSPACE/out/" .

          git add -A
          git commit -m "Update files" || echo "Nothing to commit."

          git remote add origin "https://x-access-token:${GH_TOKEN}@github.com/${ORG}/${REPO}.git"
          git push -u origin main --force

      # 5) Set org secrets
      - name: Set org secrets (dispatcher + provisioner)
        env:
          ORG: ${{ inputs.org }}
          DISPATCHER_APP_ID: ${{ vars.DISPATCHER_APP_ID }}
          DISPATCHER_PRIVATE_KEY_PEM: ${{ secrets.DISPATCHER_PRIVATE_KEY_PEM }}
          PROVISIONER_APP_ID: ${{ vars.PROVISIONER_APP_ID }}
          PROVISIONER_PRIVATE_KEY_PEM: ${{ secrets.PROVISIONER_PRIVATE_KEY_PEM }}
        run: |
          set -euo pipefail

          # --- ORG VARIABLES (non-sensitive) ---
          echo "$ORG"  | gh variable set ORG  --org "$ORG" --visibility all
          
          echo "$DISPATCHER_APP_ID"  | gh variable set DISPATCHER_APP_ID  --org "$ORG" --visibility all
          echo "$PROVISIONER_APP_ID" | gh variable set PROVISIONER_APP_ID --org "$ORG" --visibility all

          # --- ORG SECRETS (sensitive) ---
          echo "$DISPATCHER_PRIVATE_KEY_PEM"  | gh secret set DISPATCHER_PRIVATE_KEY_PEM  --org "$ORG" --visibility all
          echo "$PROVISIONER_PRIVATE_KEY_PEM" | gh secret set PROVISIONER_PRIVATE_KEY_PEM --org "$ORG" --visibility all

      # 6) Set repo secrets (auditor only)
      - name: Set auditor secrets on {org}.github.io
        env:
          ORG: ${{ inputs.org }}
          AUDITOR_APP_ID: ${{ vars.AUDITOR_APP_ID }}
          AUDITOR_PRIVATE_KEY_PEM: ${{ secrets.AUDITOR_PRIVATE_KEY_PEM }}
        run: |
          set -euo pipefail
          TARGET="${ORG}/${ORG}.github.io"

          # --- REPO VARIABLES (non-sensitive) ---
          echo "$AUDITOR_APP_ID" | gh variable set AUDITOR_APP_ID --repo "$TARGET"

          # --- REPO SECRETS (sensitive) ---
          echo "$AUDITOR_PRIVATE_KEY_PEM" | gh secret set AUDITOR_PRIVATE_KEY_PEM --repo "$TARGET"

      # 7) Enable Pages (optional)
      - name: Enable GitHub Pages (optional)
        env:
          ORG: ${{ inputs.org }}
        run: |
          set -euo pipefail
          REPO="${ORG}.github.io"
          gh api "repos/${ORG}/${REPO}/pages" -X POST \
            -f source[branch]=main \
            -f source[path]="/" >/dev/null 2>&1 || true