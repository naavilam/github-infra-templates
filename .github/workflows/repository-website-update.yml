name: Update Websites (org)

on:
  workflow_call:
    inputs:
      repo:
        description: "Target repository or else all."
        required: false
        type: string
        default: ""
      registry_path:
        description: "Path to registry in the caller repo"
        required: false
        type: string
        default: ".github/registry/repos.yml"
    secrets:
      PROVISIONER_APP_ID:
        required: true
      PROVISIONER_PRIVATE_KEY_PEM:
        required: true

permissions:
  contents: write

env:
  CENTRAL_REPO: naavilam/github-infra-templates
  TEMPLATE_REF: main
  MAX_PARALLEL: "10"

jobs:
  plan:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - run: |
          python -m pip install --upgrade pip
          pip install pyyaml

      - name: Mint Provisioner GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.PROVISIONER_APP_ID }}
          private-key: ${{ secrets.PROVISIONER_PRIVATE_KEY_PEM }}
          owner: ${{ github.repository_owner }}

      - id: set
        name: Build matrix (local registry OR manager registry)
        env:
        GH_TOKEN: ${{ steps.app-token.outputs.token }}
        REGISTRY_PATH: ${{ inputs.registry_path }}
        REPO_FILTER: ${{ inputs.repo }}
        CALLER_REPO: ${{ github.repository }}
        OWNER: ${{ github.repository_owner }}
        run: |
        python - <<'PY'
        import os, sys, json, base64
        from pathlib import Path
        import yaml, requests

        gh_token = os.environ["GH_TOKEN"]
        registry_path = (os.environ.get("REGISTRY_PATH") or ".github/registry/repos.yml").strip()
        repo_filter = (os.environ.get("REPO_FILTER") or "").strip()
        caller_repo = (os.environ.get("CALLER_REPO") or "").strip()          # org/repo (onde está rodando)
        owner = (os.environ.get("OWNER") or "").strip()

        # infer manager repo
        registry_repo = f"{owner}/{owner}.github.io"

        def api_get(url):
          r = requests.get(
            url,
            headers={
              "Authorization": f"Bearer {gh_token}",
              "Accept": "application/vnd.github+json",
              "X-GitHub-Api-Version": "2022-11-28",
            },
            timeout=30,
          )
          return r

        def load_registry():
          # 1) tenta local (quando estiver no manager)
          p = Path(registry_path)
          if p.exists():
            data = yaml.safe_load(p.read_text(encoding="utf-8")) or {}
            return data

          # 2) busca do manager via contents API
          url = f"https://api.github.com/repos/{registry_repo}/contents/{registry_path}?ref=main"
          r = api_get(url)
          if r.status_code != 200:
            print(f"::error::registry not found locally and cannot fetch from {registry_repo}:{registry_path} (http {r.status_code})", file=sys.stderr)
            sys.exit(2)
          j = r.json()
          content = j.get("content","")
          if not content:
            print(f"::error::registry content empty from {registry_repo}:{registry_path}", file=sys.stderr)
            sys.exit(2)
          raw = base64.b64decode(content.encode("utf-8"))
          data = yaml.safe_load(raw.decode("utf-8")) or {}
          return data

        data = load_registry()
        repos = data.get("repos", [])
        if not isinstance(repos, list):
          repos = []

        # Decide o alvo:
        # - se inputs.repo veio, usa ele (aceita "name" ou "org/name")
        # - se inputs.repo vazio:
        #   - se está rodando no manager repo, modo "all"
        #   - senão (repo disciplina), modo "single caller"
        is_manager = (caller_repo.lower() == registry_repo.lower())
        target = repo_filter
        if not target:
          target = "" if is_manager else caller_repo  # manager => all; disciplina => só ele mesmo

        def norm(s): return (s or "").strip().lower()

        inc=[]
        for it in repos:
          if not isinstance(it, dict):
            continue
          name = (it.get("name") or "").strip()
          org  = (it.get("org") or "").strip() or owner
          if not name:
            continue

          full = f"{org}/{name}"

          # filtra
          if target:
            t = target
            if "/" not in t:
              # alvo veio só como name
              if norm(name) != norm(t):
                continue
            else:
              if norm(full) != norm(t):
                continue

          cfg = {
            "TITLE_1":    str(it.get("id") or "").strip(),
            "TITLE_2":    str(it.get("title") or "").strip(),
            "SUBTITLE_1": str(it.get("academic_area") or "").strip(),
            "SUBTITLE_2": str(it.get("academic_level") or "").strip(),
            "ABOUT":      str(it.get("site_description") or "").strip(),
            "CTA_TEXT":   str(it.get("readme_cta_text") or "").strip(),
            "TAGLINE":    str(it.get("readme_tagline") or "").strip(),
            "THEME":      str(it.get("readme_theme") or "").strip(),
            "HERO_FILE":  str(it.get("site_hero_image") or "").strip(),
            "GITHUB_LINK": f"https://github.com/{full}",
            "CENTRAL_REPO": f"https://{org}.github.io"
          }
          cfg = {k:v for k,v in cfg.items() if v}
          inc.append({"repo": full, "cfg": cfg})

        matrix = {"include": inc}
        print(json.dumps(matrix, ensure_ascii=False))

        # outputs
        out_path = os.environ["GITHUB_OUTPUT"]
        with open(out_path, "a", encoding="utf-8") as f:
          f.write("count=%d\n" % len(inc))
          f.write("matrix=%s\n" % json.dumps(matrix, ensure_ascii=False))
        PY

  apply:
    needs: plan
    runs-on: ubuntu-latest
    if: ${{ needs.plan.outputs.count != '0' }}
    strategy:
      fail-fast: false
      max-parallel: 10
      matrix: ${{ fromJson(needs.plan.outputs.matrix) }}

    steps:
      - name: Mint Provisioner GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.PROVISIONER_APP_ID }}
          private-key: ${{ secrets.PROVISIONER_PRIVATE_KEY_PEM }}
          owner: ${{ github.repository_owner }}

      - name: Checkout target repo (gh-pages)
        uses: actions/checkout@v4
        with:
          repository: ${{ matrix.repo }}
          token: ${{ steps.app-token.outputs.token }}
          path: target
          fetch-depth: 0

      - name: Ensure gh-pages branch exists and is checked out
        shell: bash
        run: |
          set -euo pipefail
          cd target
          git fetch origin gh-pages || true
          if git show-ref --verify --quiet refs/remotes/origin/gh-pages; then
            git checkout -B gh-pages origin/gh-pages
          else
            git checkout --orphan gh-pages
            git rm -rf . >/dev/null 2>&1 || true
          fi

      - name: Checkout central templates + scripts
        uses: actions/checkout@v4
        with:
          repository: ${{ env.CENTRAL_REPO }}
          ref: ${{ env.TEMPLATE_REF }}
          path: central
          sparse-checkout: |
            bootstrap/repo_website
            bootstrap/repo_scripts/build_site.py
          sparse-checkout-cone-mode: false

      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - run: |
          python -m pip install --upgrade pip
          pip install pyyaml nbconvert

      - name: Write website cfg (from matrix) (safe)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p _cfg
          python - <<'PY'
          import os, json, yaml
          cfg = json.loads(os.environ.get("CFG_JSON","{}"))
          with open("_cfg/website.yml","w",encoding="utf-8") as f:
            yaml.safe_dump(cfg, f, sort_keys=False, allow_unicode=True)
          print("[ok] wrote _cfg/website.yml")
          PY
        env:
          CFG_JSON: ${{ toJson(matrix.cfg) }}

      - name: Build site into _site (gh-pages content)
        shell: bash
        run: |
          set -euo pipefail
          python central/bootstrap/repo_scripts/build_site.py \
            --src target \
            --out _site \
            --template central/bootstrap/repo_website \
            --title "${{ matrix.repo }}" \
            --execute "false" \
            --cfg "_cfg/website.yml"

      - name: Replace gh-pages content
        shell: bash
        run: |
          set -euo pipefail
          cd target

          # limpa tudo (menos .git)
          find . -mindepth 1 -maxdepth 1 ! -name ".git" -exec rm -rf {} +

          # copia site gerado
          cp -R ../_site/* .

          # identidade bot por org (agnóstico)
          ORG_LC="$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')"
          BOT="${ORG_LC}-provisioner-app[bot]"
          git config user.name "${BOT}"
          git config user.email "${BOT}@users.noreply.github.com"

          if git diff --quiet && git status --porcelain | wc -l | grep -q '^0$'; then
            echo "No changes."
            exit 0
          fi

          git add -A
          git commit -m "Update files"
          git push origin gh-pages

      - name: Guardrail ensure gh-pages ref exists
        shell: bash
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          REPO: ${{ matrix.repo }}
        run: |
          set -euo pipefail
          OWNER="${REPO%/*}"
          NAME="${REPO#*/}"
          REF_URL="https://api.github.com/repos/${OWNER}/${NAME}/git/ref/heads/gh-pages"

          echo "Checking ref: ${OWNER}/${NAME} heads/gh-pages"

          ok=0
          for i in {1..20}; do
            code="$(curl -sS -o /tmp/ref.json -w "%{http_code}" \
              -H "Authorization: Bearer ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              "${REF_URL}" || true)"

            if [[ "$code" == "200" ]]; then
              sha="$(jq -r '.object.sha // empty' /tmp/ref.json || true)"
              echo "gh-pages exists (sha=${sha})"
              ok=1
              break
            fi

            echo "gh-pages not visible yet (http=${code}) attempt=${i}"
            sleep 2
          done

          if [[ "$ok" != "1" ]]; then
            echo "::error::gh-pages ref not visible after retries; cannot enable Pages safely."
            exit 1
          fi

      - name: Enable GitHub Pages (source=gh-pages)
        shell: bash
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          REPO: ${{ matrix.repo }}
        run: |
          set -euo pipefail
          OWNER="${REPO%/*}"
          NAME="${REPO#*/}"
          API="https://api.github.com/repos/${OWNER}/${NAME}/pages"
          BODY='{"source":{"branch":"gh-pages","path":"/"}}'

          http="$(curl -sS -o /tmp/pages.json -w "%{http_code}" -X POST \
            -H "Authorization: Bearer ${GH_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            "${API}" \
            -d "${BODY}" || true)"

          if [[ "$http" == "409" || "$http" == "422" ]]; then
            http="$(curl -sS -o /tmp/pages.json -w "%{http_code}" -X PUT \
              -H "Authorization: Bearer ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              "${API}" \
              -d "${BODY}" || true)"
          fi

          echo "pages http=${http}"
          cat /tmp/pages.json || true

          if [[ "${http}" -lt 200 || "${http}" -ge 300 ]]; then
            echo "::error::Failed to configure GitHub Pages (HTTP ${http})."
            exit 1
          fi