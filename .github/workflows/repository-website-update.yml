name: Update Websites (org)

on:
  workflow_call:
    inputs:
      repo:
        description: "Target repository or else all."
        required: false
        type: string
        default: ""

    secrets:
      PROVISIONER_APP_ID:
        required: true
      PROVISIONER_PRIVATE_KEY_PEM:
        required: true

permissions:
  contents: write

env:
  CENTRAL_REPO: naavilam/github-infra-templates
  TEMPLATE_REF: main
  MAX_PARALLEL: "10"

jobs:
  plan:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set.outputs.matrix }}
      count:  ${{ steps.set.outputs.count }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - run: |
          python -m pip install --upgrade pip
          pip install pyyaml requests

      - name: Mint Provisioner GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.PROVISIONER_APP_ID }}
          private-key: ${{ secrets.PROVISIONER_PRIVATE_KEY_PEM }}
          owner: ${{ github.repository_owner }}
    
      - id: set
        name: Build matrix from CENTRAL org registry (with embedded cfg)
        shell: bash
        env:
          ORG: ${{ github.repository_owner }}                
          REPO_FILTER: ${{ inputs.repo }}
          CENTRAL_REPO: ${{ env.CENTRAL_REPO }}
          TEMPLATE_REF: ${{ env.TEMPLATE_REF }}
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          set -euo pipefail

          reg_path = f"org/org_registry/{org_lc}-registry.yml"
          echo "PWD=$(pwd)"
          echo "REPO_FILTER='${REPO_FILTER}'"
          echo "REGISTRY_PATH='${reg_path}'"
          ls -la
          echo "---- find registry candidates ----"
          find . -maxdepth 4 -type f \( -name "*registry*.yml" -o -name "*repos*.yml" \) -print
          echo "---- show registry file (if exists) ----"
          test -f "${reg_path}" && sed -n '1,120p' "${reg_path}" || echo "registry file not found at REGISTRY_PATH"
         
          python - <<'PY'
          import os, sys, json, base64, re
          import requests, yaml

          org = (os.environ.get("ORG") or "").strip()
          if not org:
            raise SystemExit("::error::ORG env is required")

          repo_filter = (os.environ.get("REPO_FILTER") or "").strip()
          central_repo = (os.environ.get("CENTRAL_REPO") or "").strip()
          template_ref = (os.environ.get("TEMPLATE_REF") or "main").strip()
          gh_token = os.environ["GH_TOKEN"]

          # central path do NOVO registry
          org_lc = org.lower()
          reg_path = f"org/org_registry/{org_lc}-registry.yml"

          def api_get_contents(path: str):
            url = f"https://api.github.com/repos/{central_repo}/contents/{path}"
            r = requests.get(
              url,
              headers={
                "Authorization": f"Bearer {gh_token}",
                "Accept": "application/vnd.github+json",
                "X-GitHub-Api-Version": "2022-11-28",
              },
              params={"ref": template_ref},
              timeout=30,
            )
            return r

          r = api_get_contents(reg_path)
          if r.status_code != 200:
            print(f"::error::cannot fetch registry from {central_repo}:{reg_path}@{template_ref} (http {r.status_code})", file=sys.stderr)
            print(r.text, file=sys.stderr)
            sys.exit(2)

          j = r.json()
          content_b64 = j.get("content", "")
          if not content_b64:
            print(f"::error::empty registry content at {reg_path}", file=sys.stderr)
            sys.exit(2)

          raw = base64.b64decode(content_b64.encode("utf-8")).decode("utf-8")
          data = yaml.safe_load(raw) or {}

          items = data.get("repos", [])
          if not isinstance(items, list):
            items = []

          def norm(s: str) -> str:
            return (s or "").strip().lower()

          def slug_repo(name: str) -> str:
            # IMPORTANTÍSSIMO: GitHub “normaliza” alguns chars (ex: '(' e ')')
            # então a gente normaliza igual para bater com o nome real do repo
            s = (name or "").strip()
            s = s.replace("(", "-").replace(")", "-")
            s = re.sub(r"-{2,}", "-", s).strip("-")
            return s

          include = []
          for it in items:
            raw_name = str(it.get("name","")).strip()
            if not raw_name:
              continue

            name = slug_repo(raw_name)
            full = f"{org_lc}/{name}"

            # filtro: aceita "repo" OU "org/repo"
            if repo_filter:
              rf = repo_filter.strip()
              if "/" in rf:
                if norm(full) != norm(rf):
                  continue
              else:
                if norm(name) != norm(rf) and norm(raw_name) != norm(rf) and norm(slug_repo(rf)) != norm(name):
                  continue

            course_id = (it.get("id") or "").strip() or name
            title = (it.get("title") or "").strip()
            area  = (it.get("academic_area") or "").strip()
            level = (it.get("academic_level") or "").strip()

            tagline = (it.get("readme_tagline") or "").strip()
            if not tagline:
              parts = [p for p in [area, level] if p]
              tagline = " • ".join(parts) if parts else "lectures • notebooks • references"

            site_url = (it.get("site_url") or "").strip()
            if not site_url:
              site_url = f"https://{org_lc}.github.io/{name}"

            cfg = {
              "TITLE_1": course_id,
              "TITLE_2": title or name.replace("-", " "),
              "REPO_TAGLINE": tagline,
              "CTA_TEXT": (it.get("readme_cta_text") or "Access the full course website").strip(),
              "THEME": (it.get("readme_theme") or "coding").strip(),
              "SITE_URL": site_url,
              "HERO_FILE": (it.get("site_hero_image") or "").strip(),
              "GITHUB_LINK": f"https://github.com/{full}",
              "CENTRAL_REPO": f"https://{org_lc}.github.io",
            }
            cfg = {k:v for k,v in cfg.items() if v}

            payload = json.dumps(cfg, separators=(",", ":"), ensure_ascii=False).encode("utf-8")
            cfg_b64 = base64.urlsafe_b64encode(payload).decode("ascii")

            include.append({"repo": full, "cfg_b64": cfg_b64})

          matrix = {"include": include}
          out_path = os.environ["GITHUB_OUTPUT"]
          with open(out_path, "a", encoding="utf-8") as f:
            f.write(f"matrix={json.dumps(matrix, ensure_ascii=False)}\n")
            f.write(f"count={len(include)}\n")

          print(f"[ok] selected={len(include)} from {reg_path}")
          PY

      - name: Debug plan outputs
        shell: bash
        run: |
          echo "count (from step.set.outputs.count) = '${{ steps.set.outputs.count }}'"
          echo "matrix (from step.set.outputs.matrix) ="
          echo '${{ steps.set.outputs.matrix }}'

  apply:
    needs: plan
    runs-on: ubuntu-latest
    if: ${{ needs.plan.outputs.count != '0' }}
    strategy:
      fail-fast: false
      max-parallel: 10
      matrix: ${{ fromJson(needs.plan.outputs.matrix) }}

    steps:
      - name: Mint Provisioner GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.PROVISIONER_APP_ID }}
          private-key: ${{ secrets.PROVISIONER_PRIVATE_KEY_PEM }}
          owner: ${{ github.repository_owner }}

      # 1) FONTES (main)
      - name: Checkout source repo (main)
        uses: actions/checkout@v4
        with:
          repository: ${{ matrix.repo }}
          token: ${{ steps.app-token.outputs.token }}
          ref: main
          path: src
          fetch-depth: 1

      # 2) PUBLICAÇÃO (gh-pages)
      - name: Checkout publish repo (gh-pages)
        uses: actions/checkout@v4
        with:
          repository: ${{ matrix.repo }}
          token: ${{ steps.app-token.outputs.token }}
          ref: gh-pages
          path: target
          fetch-depth: 0

      - name: Ensure gh-pages branch exists (if first publish)
        shell: bash
        run: |
          set -euo pipefail
          cd target
          git fetch origin gh-pages || true
          if git show-ref --verify --quiet refs/remotes/origin/gh-pages; then
            git checkout -B gh-pages origin/gh-pages
          else
            git checkout --orphan gh-pages
            git rm -rf . >/dev/null 2>&1 || true
          fi

      - name: Checkout central templates + scripts
        uses: actions/checkout@v4
        with:
          repository: ${{ env.CENTRAL_REPO }}
          ref: ${{ env.TEMPLATE_REF }}
          path: central
          sparse-checkout: |
            bootstrap/repo_website
            bootstrap/repo_scripts/build_site.py
            img/portfolio
          sparse-checkout-cone-mode: false

      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - run: |
          python -m pip install --upgrade pip
          pip install pyyaml nbconvert nbformat jinja2

      - name: Write website cfg (from matrix) (safe)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p _cfg
          python - <<'PY'
          import os, json, yaml
          cfg = json.loads(os.environ.get("CFG_JSON","{}"))
          with open("_cfg/website.yml","w",encoding="utf-8") as f:
            yaml.safe_dump(cfg, f, sort_keys=False, allow_unicode=True)
          print("[ok] wrote _cfg/website.yml")
          PY
        env:
          CFG_JSON: ${{ toJson(matrix.cfg) }}

      - name: Checkout manager assets (hero)
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/${{ github.repository_owner }}.github.io
          token: ${{ steps.app-token.outputs.token }}
          ref: main
          path: manager
          sparse-checkout: |
            img/portfolio
          sparse-checkout-cone-mode: false
          fetch-depth: 1

      - name: Fetch hero image (from central templates)
        shell: bash
        run: |
          set -euo pipefail

          HERO_FILE="$(python - <<'PY'
          import yaml
          from pathlib import Path
          cfg = yaml.safe_load(Path("_cfg/website.yml").read_text(encoding="utf-8")) or {}
          print((cfg.get("HERO_FILE") or "").strip())
          PY
          )"

          if [[ -z "${HERO_FILE}" ]]; then
            echo "Sem HERO_FILE no cfg -> pulando hero."
            exit 0
          fi

          SRC="central/manager/manager_assets/${{ github.repository_owner }}/img/portfolio/${HERO_FILE}"
          if [[ ! -f "$SRC" ]]; then
            echo "::error::HERO_FILE '${HERO_FILE}' não encontrado no central templates em $SRC"
            echo "Conteúdo de central/manager/manager_assets/${{ github.repository_owner }}/img/portfolio:"
            ls -la "central/manager/manager_assets/${{ github.repository_owner }}/img/portfolio" || true
            exit 1
          fi

          mkdir -p _site/assets/img
          cp "$SRC" _site/assets/img/hero.png
          echo "[ok] hero copiado: $SRC -> _site/assets/img/hero.png"

          # garante que o template use a imagem local publicada (robusto)
          python - <<'PY'
          import yaml
          from pathlib import Path
          p = Path("_cfg/website.yml")
          cfg = yaml.safe_load(p.read_text(encoding="utf-8")) or {}
          cfg["HERO_URL"] = "/assets/img/hero.png"
          p.write_text(yaml.safe_dump(cfg, sort_keys=False, allow_unicode=True), encoding="utf-8")
          print("[ok] set HERO_URL=/assets/img/hero.png")
          PY

      - name: Set HERO_URL in cfg
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY'
          import yaml
          from pathlib import Path

          p = Path("_cfg/website.yml")
          cfg = yaml.safe_load(p.read_text(encoding="utf-8")) or {}

          # só seta se existir HERO_FILE (pra não “forçar” hero em repos sem imagem)
          if (cfg.get("HERO_FILE") or "").strip():
              cfg["HERO_URL"] = "./assets/img/hero.png"

          p.write_text(yaml.safe_dump(cfg, sort_keys=False, allow_unicode=True), encoding="utf-8")
          print("[ok] HERO_URL atualizado em _cfg/website.yml")
          PY
        
      # agora o src é a MAIN (pasta src), e out é _site
      - name: Build site into _site (from main)
        shell: bash
        run: |
          set -euo pipefail
          python central/bootstrap/repo_scripts/build_site.py \
            --src src \
            --out _site \
            --template central/bootstrap/repo_website \
            --title "${{ matrix.repo }}" \
            --execute "false" \
            --cfg "_cfg/website.yml"

      - name: Replace gh-pages content
        shell: bash
        run: |
          set -euo pipefail
          cd target
          find . -mindepth 1 -maxdepth 1 ! -name ".git" -exec rm -rf {} +
          cp -R ../_site/* .

          ORG_LC="$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')"
          BOT="${ORG_LC}-provisioner-app[bot]"
          git config user.name "${BOT}"
          git config user.email "${BOT}@users.noreply.github.com"

          if git diff --quiet && [[ -z "$(git status --porcelain)" ]]; then
            echo "No changes."
            exit 0
          fi

          git add -A
          git commit -m "Update files"
          git push origin gh-pages